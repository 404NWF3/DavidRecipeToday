# 业务背景与用户需求

### 一、 用户需求 (User Needs)

用户需求描述了**用户希望系统能为他们做什么**。我们可以通过“用户故事”（User Stories）的形式来理解：

**1. 核心功能需求 (Core Functionality)**

* **U-1 (核心搜索):** “作为一名用户，我希望我能输入我冰箱里有的几种食材（例如：鸡蛋、西红柿、洋葱），系统就能告诉我**主要使用**这些食材可以做出的菜谱列表。”
* **U-2 (查看详情):** “作为一名用户，当我从列表中选择一个菜谱时，我希望能看到完整的菜谱详情，包括：
    * 所有必需的食材列表（并**明确标出**我已有的和我**缺少**的）。
    * 详细的烹饪步骤。
    * 预计的烹饪时间、准备时间。
    * 菜谱的图片、难度评级、份量等。”
* **U-3 (处理缺少食材):** “作为一名用户，我希望系统推荐的菜谱不一定非要100%匹配我的食材。如果一个菜谱我只缺少1-2样非核心食材（比如香菜、某个调料），我仍然希望它被推荐，并告诉我缺少了什么。”

**2. 筛选与偏好需求 (Filtering & Preferences)**

* **U-4 (快速筛选):** “作为一名用户，在获得菜谱列表后，我希望能根据一些条件快速筛选，例如：
    * **快手菜** (例如：烹饪时间 < 20分钟)。
    * **餐食类型** (例如：早餐、午餐、晚餐、甜点)。
    * **菜系风味** (例如：中餐、西餐、日料)。”
* **U-5 (饮食偏好):** “作为一名用户，我希望能设置并保存我的长期饮食偏好，系统在推荐时应自动遵循这些偏好，例如：
    * **素食主义** (Vegetarian) / **严格素食** (Vegan)。
    * **无麸质** (Gluten-Free)。
    * **过敏原** (例如：对花生、海鲜过敏)。”

**3. 辅助功能需求 (Auxiliary Features)**

* **U-6 (虚拟食品柜):** “作为一名用户，我希望能保存我家中常备的食材（我的‘虚拟食品柜’），这样我下次就不用重新输入了。”
* **U-7 (收藏功能):** “作为一名用户，我希望能收藏我喜欢的菜谱，以便将来查看。”
* **U-8 (发现新菜谱):** “作为一名用户，即使我不输入食材，我也希望能浏览或搜索平台上的热门菜谱或新菜谱。”

---

### 二、 业务逻辑 (Business Logic)

业务逻辑描述了**系统内部如何工作**以满足上述用户需求。这是你设计数据库和后端API的核心。

**B-1: 食材的标准化与管理 (Ingredient Management)**

* **挑战：** 用户输入的“土豆”和“马铃薯”，或者“西红柿”和“番茄”，在系统中应被视为同一种食材。
* **逻辑：** 你需要一个**“食材主表” (Ingredients)**。
    * 每种食材应有一个唯一的 `ingredient_id`。
    * 应有一个“标准名称” (e.g., `name` = "马铃薯")。
    * 需要一个“别名表” (IngredientAliases) 或在主表中使用一个 `aliases` 字段（如JSON或文本数组），用于映射用户的模糊输入 (e.g., "土豆", "洋芋"都指向 "马铃薯" 的 `ingredient_id`)。
    * 食材可以被分类 (e.g., `category` = "蔬菜", "肉类", "调料")。这有助于后续的智能推荐（例如，调料通常不作为核心食材）。

**B-2: 菜谱的构成与关系 (Recipe Structure)**

* **逻辑：** 你需要一个**“菜谱表” (Recipes)**。
    * 包含 `recipe_id`, `title` (标题), `instructions` (步骤), `prep_time` (准备时间), `cook_time` (烹饪时间), `servings` (份量), `image_url` 等。
* **逻辑：** 你需要“标签表” (Tags) 和 “菜谱-标签关联表” (Recipe_Tags)。
    * Tags表存储如 "素食", "快手菜", "中餐" 等标签。
    * `Recipe_Tags` (多对多) 用来给菜谱打上 `U-4` 和 `U-5` 中提到的各种筛选标记。
* **逻辑 (核心)：** 你需要一个**“菜谱-食材关联表” (Recipe_Ingredients)**。
    * 这是连接 `Recipes` 和 `Ingredients` 的多对多表。
    * **关键字段：** `recipe_id`, `ingredient_id`。
    * **重要附加字段：**
        * `quantity` (用量, e.g., "100克", "2个")：用于 `U-2` 展示。
        * `is_core_ingredient` (是否核心食材, 布尔值)：**这非常重要！** “宫保鸡丁”里的“鸡肉”是核心，但“盐”和“香菜”不是。这有助于 `B-3` 的匹配逻辑。
        * `notes` (备注, e.g., "切碎", "可选")。

* **逻辑：** 你需要一个**“菜谱步骤表” (Recipe_Steps)**。
    * 用于以结构化的方式存储每个菜谱的分步说明，便于排序展示与多媒体扩展，直接服务于 `U-2` 的“详细的烹饪步骤”。
    * **关键字段：**
        * `step_id` (Primary Key)
        * `recipe_id` (Foreign Key)
        * `step_number` (Integer，从1开始，表示步骤序号)
        * `instruction_text` (TEXT，步骤描述)
        * `duration_seconds` (Integer，可选，建议用秒来统一计时)
        * `image_url` / `video_url` (可选，多媒体链接)
        * `notes` (可选，提示/注意事项/定时器提示)
    * **约束建议：**
        * `(recipe_id, step_number)` 唯一，确保每个菜谱的步骤序号不重复。
        * 删除菜谱时级联删除其步骤。
    * **展示建议：**
        * 前端按 `step_number` 升序展示；如有 `duration_seconds`，可展示总耗时统计。

**B-3: 核心匹配与查询逻辑 (Core Matching Logic)**

这是系统的灵魂，直接服务于 `U-1` 和 `U-3`。

* **输入：** 用户食材列表 (一个 `ingredient_id` 的数组), 记为 `UserPantry`。
* **目标：** 查询 `Recipes` 表，并按“匹配度”排序。
* **“匹配度”如何定义？** 这是你的核心算法：
    1.  **查询：** 找到所有**至少包含一个** `UserPantry` 中食材的菜谱。
    2.  **计算 (对每个找到的菜谱)：**
        * `TotalIngredients` (该菜谱所需的总食材数)。
        * `MatchedIngredients` (该菜谱中，用户已有的食材数)。
        * `MissingIngredients` (该菜谱中，用户缺少的食材数) = `TotalIngredients` - `MatchedIngredients`。
        * `MatchedCoreIngredients` (用户已有的**核心**食材数)。
        * `MissingCoreIngredients` (用户缺少的**核心**食材数)。
* **排序 (Ranking Logic):** 你可以设计一个评分公式 `MatchScore`。一个简单的排序逻辑可以是：
    1.  **第一优先级 (必要条件)：** `MissingCoreIngredients` = 0 (所有核心食材必须都有)。
    2.  **第二优先级 (主要排序)：** 按 `MissingIngredients` **升序**排列 (缺少的食材越少越好)。
    3.  **第三优先级 (次要排序)：** 按 `MatchedIngredients` **降序**排列 (在缺少食材数相同的情况下，用的食材越多越好)。

* **示例：**
    * 用户有：{鸡肉, 花生, 葱}
    * 菜谱A (宫保鸡丁)：需{鸡肉, 花生, 葱, 辣椒, 盐, 糖} (核心: 鸡肉, 花生)
        * `MissingCore` = 0
        * `Missing` = 3 (辣椒, 盐, 糖)
    * 菜谱B (白切鸡)：需{鸡肉, 葱, 姜, 盐} (核心: 鸡肉)
        * `MissingCore` = 0
        * `Missing` = 2 (姜, 盐)
    * 菜谱C (花生酥)：需{花生, 面粉, 糖} (核心: 花生, 面粉)
        * `MissingCore` = 1 (缺少面粉)
    * **系统推荐顺序：** 菜谱B (第一) > 菜谱A (第二) > 菜谱C (不推荐或排在最后)。

**B-4: 用户个性化逻辑 (User Personalization Logic)**

* **逻辑：** 你需要 `Users` 表, `Favorite_Recipes` 表 (多对多), `User_Pantry` 表 (多对多, `user_id` <-> `ingredient_id`)。
* **逻辑 (筛选)：** 当用户（`U-5`）设置了 "素食" 偏好时，所有 `B-3` 的查询都必须额外附加一个 `WHERE` 条件，即该菜谱必须在 `Recipe_Tags` 中关联了 "素食" 标签。过敏原同理。

---

### B-5: 菜谱评论与评分 (Recipe Reviews & Ratings)

* **目的：** 支持用户对菜谱进行评分与评论，用于质量反馈、排序与“发现新菜谱”场景的加权信号。
* **数据模型：** `Recipe_Reviews`（一条评论属于一个菜谱和一个用户）。
    * 为避免刷评，通常约束一个用户对同一菜谱只保留一条有效评论：`UNIQUE (user_id, recipe_id)`。
* **关键字段：**
    * `review_id` (Primary Key)
    * `recipe_id` (Foreign Key)
    * `user_id` (Foreign Key)
    * `rating` (Integer，范围 1–5)
    * `title` (可选)
    * `content` (TEXT，可选)
    * `created_at`, `updated_at`
    * `is_visible` / `is_deleted` (Boolean，审核与软删除)
    * `helpful_count`, `reported_count` (可选，点赞/举报计数)
* **业务规则：**
    * 校验评分范围；更新评论时刷新 `updated_at`。
    * 审核采用软删除/可见性控制，保留取证与恢复的可能。
    * 展示时可按“有图优先（若后续扩展评论图片）、评分高优先、时间近优先”组合排序。
* **聚合与冗余：**
    * `Recipes` 表可维护 `average_rating` 与 `review_count` 作为冗余字段，以加速列表页排序与筛选。
    * 冗余可通过触发器、异步任务或物化视图维护，确保一致性与性能平衡。
* **个性化与排序：**
    * 在 `B-3` 的排序中可把 `average_rating` 作为次级权重；`U-8` 场景可按评分和热度（`review_count`）综合推荐。

---

### 总结：从需求到数据库的下一步思考

基于以上的分析，你的数据库模式（Schema）将至少包含以下几个核心表：

1.  **`Ingredients` (食材主表)**
    * `ingredient_id` (Primary Key)
    * `name` (标准名称, e.g., "马铃薯")
    * `category` (e.g., "蔬菜", "调料")
    * `aliases` (别名, e.g., ["土豆", "洋芋"])
2.  **`Recipes` (菜谱表)**
    * `recipe_id` (Primary Key)
    * `title`, `description`, `instructions` (TEXT类型)
    * `prep_time_minutes`, `cook_time_minutes` (Integer)
    * `average_rating` (Float，可选，聚合自评论)
    * `review_count` (Integer，可选，聚合自评论)
    * ... (其他详情)
3.  **`Recipe_Ingredients` (菜谱-食材关联表 - 多对多)**
    * `recipe_id` (Foreign Key)
    * `ingredient_id` (Foreign Key)
    * `quantity_display` (e.g., "100克", "2个")
    * `is_core_ingredient` (Boolean, **关键字段**)
4.  **`Tags` (标签表)**
    * `tag_id` (Primary Key)
    * `tag_name` (e.g., "素食", "快手菜", "中餐")
5.  **`Recipe_Tags` (菜谱-标签关联表 - 多对多)**
    * `recipe_id` (Foreign Key)
    * `tag_id` (Foreign Key)
6.  **`Users` (用户表)** (用于个性化功能)
7.  **`Favorite_Recipes`** (用户收藏表 - 多对多)
8.  **`User_Pantry`** (用户虚拟食品柜 - 多对多)

9.  **`Recipe_Steps` (菜谱步骤表)**
    * `step_id` (Primary Key)
    * `recipe_id` (Foreign Key)
    * `step_number` (Integer，从1开始)
    * `instruction_text` (TEXT)
    * `duration_seconds` (Integer，可选)
    * `image_url` / `video_url` (可选)
    * `notes` (可选)
    * 约束：`UNIQUE (recipe_id, step_number)`；删除菜谱时级联删除步骤。

10. **`Recipe_Reviews` (菜谱评论表)**
    * `review_id` (Primary Key)
    * `recipe_id` (Foreign Key)
    * `user_id` (Foreign Key)
    * `rating` (Integer，1–5)
    * `title` (可选)
    * `content` (TEXT，可选)
    * `created_at`, `updated_at`
    * `is_visible` (Boolean，默认 true) / `is_deleted` (Boolean，默认 false)
    * `helpful_count`, `reported_count` (可选)
    * 约束：`UNIQUE (user_id, recipe_id)`。

准确理解这些用户需求和业务逻辑，是设计出高效、可扩展数据库的第一步，也是最关键的一步。